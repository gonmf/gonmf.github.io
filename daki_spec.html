<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="author" content="Gonçalo Mendes Ferreira">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Permissions-Policy" content="interest-cohort=()"/>

    <title>Daki Language Specification</title>

    <link rel="canonical" href="https://macro.win/daki_spec.html">
    <link rel="icon" type="image/png" sizes="16x16" href="data:image/png;base64,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" />
    <link rel="stylesheet" href="style.css" />
  </head>

  <body>
    <div class="container">
      <nav>
        <a class="back" href="dakilang.html">← Home</a>
      </nav>

      <header>
        <h1>Daki Language Specification</h1>

        <p>Daki is a small computer programming language inspired by Prolog and Datalog. It is a declarative, logic, typed language based on Horn clauses, aimed at solving problems via deduction.</p>
      </header>

      <main>
        <p>To execute a Daki program you must use a Daki language interpreter. You can find on GitHub <a href="https://github.com/gonmf/dakilang" rel="noopener">the reference interpreter</a> (<a href="https://repo.or.cz/dakilang.git" rel="noopener">mirror</a>).</p>

        <p>Regardless of your familiarity with Prolog or Datalog, the Daki language has significant differences to both. For this reason the following short language definition has been compiled, with examples.</p>

        <h2>Contents</h2>

        <ul>
          <li><a class="no-print" href="#introduction">Introduction</a></li>
          <li><a class="no-print" href="#comments">Comments</a></li>
          <li><a class="no-print" href="#declarations">Declarations</a></li>
          <ul>
            <li><a class="no-print" href="#data-types">Data types</a></li>
          </ul>
          <li><a class="no-print" href="#queries">Queries</a></li>
          <ul>
            <li><a class="no-print" href="#short_queries">Short queries</a></li>
            <li><a class="no-print" href="#anonymous_arguments">Anonymous arguments</a></li>
          </ul>
          <li><a class="no-print" href="#retractions">Retractions</a></li>
          <li><a class="no-print" href="#commands">Environment commands</a></li>
          <li><a class="no-print" href="#operator-clauses">Operator clauses</a></li>
          <ul>
            <li><a class="no-print" href="#arithmetic-operator-clauses">Arithmetic operator clauses</a></li>
            <li><a class="no-print" href="#bitwise-operator-clauses">Bitwise operator clauses</a></li>
            <li><a class="no-print" href="#comparison-operator-clauses">Equality/order operator clauses</a></li>
            <li><a class="no-print" href="#type-casting_operator-clauses">Type casting operator clauses</a></li>
            <li><a class="no-print" href="#string-operator-clauses">String operator clauses</a></li>
            <li><a class="no-print" href="#list-operator-clauses">List operator clauses</a></li>
            <li><a class="no-print" href="#other-operator-clauses">Other operator clauses</a></li>
          </ul>
          <li><a class="no-print" href="#clause-conditions">Clause conditions</a></li>
          <ul>
            <li><a class="no-print" href="#condition-operators">Condition Operators</a></li>
          </ul>
          <li><a class="no-print" href="#inline-operations">Inline Operations</a></li>
          <ul>
            <li><a class="no-print" href="#inline-operators">Inline Operators</a></li>
          </ul>
          <li><a class="no-print" href="#memoization">Memoization</a></li>
          <li><a class="no-print" href="#copyright">Copyright notice</a></li>
        </ul>

        <hr/>

        <a name="introduction"></a>
        <h2>Introduction</h2>

        <p>The Daki language is meant to be read by a computer. The usual flow of a Daki language computer program is to read a collection of declarations, and then allow the user to interact with the knowledge base and make questions to be solved via inference.</p>

        <p>One interesting quality about Daki is that it is meant to bridge the capabilities of Datalog with some of the more powerful features of Prolog. In Datalog queries return all solutions, while in Prolog by default only the first solution is returned. In Daki you can always easily select between the two query methods, and still have access to powerful features missing from Datalog, like a typed system and automatic memoization. There are many other differences from these languages to Daki; these are introduced where appropriate along this text.</p>

        <p>There are only five types of instructions in Daki, and these cannot be mixed (except for comments that may be inlined):</p>

        <ol>
          <li>Comments</li>
          <li>New declarations</li>
          <li>Queries</li>
          <li>Declarations to be removed</li>
          <li>Built-in commands</li>
        </ol>

        <a name="comments"></a>
        <h2>Comments</h2>

        <p>Technically not an instruction, because they are not interpreted; comments start with the "<code>#</code>" character, and everything after this character is ignored by the interpreter.</p>

        <pre>
    > # I am a comment
    >
    > fact('john', 'mary', 1). # I'm a comment too
        </pre>

        <a name="declarations"></a>
        <h2>Declarations</h2>

        <p>New declarations add what is called a clause to the global table of clauses (sometimes called database or knowledge base in other logic languages). A clause is composed of a head declaration and an optional tail, separated by the characters "<code>:-</code>".</p>

        <pre>
    > parent('john', 'emily').
    > grandparent(A, B) :- parent(A, C), parent(C, B).
        </pre>

        <p>Clauses are always terminated by a dot, "<code>.</code>". If they are declared with a tail, the tail must be evaluated true for the head to match. Clauses with a tail are called rules, while clauses without it are called facts.</p>

        <p>In Daki, the tail dependencies order is not important. In accordance with other logic languages, the "<code>,</code>" character is used to denote logical AND, and the "<code>;</code>" character logical OR. Notice how these are equivalent in Daki:</p>

        <pre>
    > rule(x) :- reason1(x); reason2(x).
    > # is for all purposes the same as
    > rule(x) :- reason1(x).
    > rule(x) :- reason2(x).
        </pre>

        <p>In Daki, all clauses have their tail dependencies resolved into clauses with only logical AND relationships, and it is in this format they are stored internally. For example:</p>

        <pre>
    > d(X, Y, X) :- (e(X); e(Y); e(Z)), (f(X); f(Y); f(Z)).
    > listing
    0: d(X, Y, X) :- e(X), f(X).
    1: d(X, Y, X) :- e(X), f(Y).
    2: d(X, Y, X) :- e(X), f(Z).
    3: d(X, Y, X) :- e(Y), f(X).
    4: d(X, Y, X) :- e(Y), f(Y).
    5: d(X, Y, X) :- e(Y), f(Z).
    6: d(X, Y, X) :- e(Z), f(X).
    7: d(X, Y, X) :- e(Z), f(Y).
    8: d(X, Y, X) :- e(Z), f(Z).
        </pre>

        <p>Notice how you can use parenthesis to declare many logical AND relationships at once.</p>

        <p>The elements of clauses always have open brackets and are declared with one or more strings. Those strings can be literals - with a specific data type - or variables.</p>

        <a name="data-types"></a>
        <h3>Data types</h3>

        <p>Literals in Daki always have an implicit data type associated. Many operations are only possible between compatible data type literals: this will be expanded on later in this document.</p>

        <p>The Daki data types are <strong>string</strong>, for Unicode strings (for example <code>'daki'</code>), <strong>integer</strong>, for arbitrary size integers (<code>42</code>), <strong>float</strong>, for IEEE 754 floating point numbers (<code>3.14</code>) and <strong>list</strong>, for sequential lists of literal values of arbitrary length and depth (<code>['john', 24, ['skiing', 'running']]</code>). This document also uses the term numeric to mean both integer and floating point values.</p>

        <p>Literal values are not automatically coerced or matched, for example:</p>

        <pre>
    > value('1', 1).
    > value(1, 2).
    > value(1.0, 3).
    > value([1], 4).
    >
    > value('1', X)?
    X = 1

    > value(1, X)? # integer  value 1 did not unify with floating point 1.0
    X = 2

    > value(1.000, X)? # integer  value 1 did not unify with floating point 1.0
    X = 3

    > value([1], X)?
    X = 4
        </pre>

        <p>Integer literals can be specified in decimal, octal, hexadecimal or binary notation:</p>

        <pre>
    > value(119).       # decimal
    > value(0170).      # octal
    > value(0x7a).      # hexadecimal
    > value(0b1111011). # binary
    > listing
    0: value(119).
    1: value(120).
    2: value(122).
    3: value(123).
        </pre>

        <p>String literals are UTF-8 encoded Unicode strings that can be enclosed both by the characters "<code>'</code>" and "<code>"</code>", and both of these can be escaped with "<code>\</code>". The character "<code>\</code>" itself is escaped with "<code>\\</code>". You can write "<code>"'"</code>" and "<code>'"'</code>", but need to escape it if the character is used for delimiting the string: "<code>"\""</code>" and "<code>'\''</code>". The characters for line feed ("<code>\n</code>"), carriage return ("<code>\r</code>") and horizontal tab ("<code>\t</code>") also need to be escaped.</p>

        <p>The character "<code>\</code>" is also used to denote line continuation: when placed at the end of a line, it is discarded and the line is joint with the line bellow. Line continuation works inside long strings as well. Commented text is only filtered to the end of the text line (the continuation character). See for example the following valid piece of code:</p>

        <pre>
    > mammal(A) :- # a simplified definition \
    >   blood(A, 'warm'), \
    >   (hasHair(A); hashFur(A)), \
    >   # laysEggs(A), Not all of us lay legs! \
    >   producesMilk(A).
        </pre>

        <p>You can also specify ASCII characters in hexadecimal in "<code>\xFF</code>" notation and Unicode in "<code>\uFFFF</code>" notation. For Unicode code unit escaping, you can use "<code>\u{FFFFF}</code>" with an arbitrary number of hexadecimal algarisms. The "<code>\x</code>" and "<code>\u</code>" parts are case-sensitive.</p>

        <p>Variable names and clause names must start with a letter and be composed of letters, algarisms and underscores.</p>

        <p>All whitespace outside of string literals is ignored. This is perfectly legal:</p>

        <pre>
    >        hello  (  World   ,   [ [ [ ' '] ] ])          .   #
    > listing
    0: hello(World, [[[' ']]]).
        </pre>

        <a name="queries"></a>
        <h2>Queries</h2>

        <p>A query has a similar format to a tailless clause, but ends with a "<code>?</code>" character instead of "<code>.</code>". Upon being input, it starts a search for all its solutions using the global table of clauses.</p>

        <p>The search will try to find all solutions for which the original query has no outstanding variables, showing the literals that have filled in those variables. When all variables of a clause head are replaced, we say it has unified.</p>

        <p>If the original query has no outstanding variables, the query is instead about verifying if that combination of literal values as arguments for the clause unify.</p>

        <p>The interpreter will print the values of the variable arguments of every solution found, or return "<code>Yes</code>" if a solution exists but the query had no variable arguments, or return "<code>No</code>" if no solution was found.</p>

        <pre>
    > parent("john", "anna").
    > parent("john", "mary").
    > parent("victor", "john").
    > parent("sophia", "john").
    > parent("victor", "victor jr").
    > parent("sophia", "victor jr").
    > grandparent(X, Y) :- parent(X, Z), parent(Z, Y).
    >
    > grandparent(A, B)?
    A = 'victor'
    B = 'anna'

    A = 'sophia'
    B = 'anna'

    A = 'victor'
    B = 'mary'

    A = 'sophia'
    B = 'mary'

    > grandparent('sophia', 'mary')?
    Yes

    > grandparent(A, A)?
    No
        </pre>

        <p>The interpreter will print a warning when a query is impossible to unify when no clauses with the same name and arity were declared.</p>

        <a name="short_queries"></a>
        <h3>Short queries</h3>

        <p>The previous queries that return all the solutions are called full queries. If the clause ends with a "<code>!</code>" instead of "<code>?</code>", a short query is performed instead. A short query terminates as soon as the first solution is found. They only return one answer, or "<code>Yes</code>" and "<code>No</code>":</p>

        <pre>
    > month('January').
    > month('February').
    > month('March').
    > month(name)!
    month = 'January'
        </pre>

        <p>Queries have a time limit to be completed. If a query times out the interpreter prints the message "<code>Search timeout</code>". A full query can timeout even after finding at least part of the solution. The default time limit is interpreter or system specific.</p>

        <p>Previously we said the order of tail clauses is not important, which is true for full queries. With short queries, the first solution found may be different depending on the order of the tail clauses. The interpreter algorithm, however, is stable: given the same definitions the result will be constant (if not introduced by built-in clauses with side effects).</p>

        <a name="anonymous_arguments"></a>
        <h3>Anonymous arguments</h3>

        <p>Sometimes we only want to know if a solution exists, or are only interested in part of the solution. Daki allows the use of anonymous arguments in queries, that unify with any value, for this purpose. They are particularly useful when a query would result in an enormous amount of output solutions.</p>

        <p>Without anonymous arguments, <i>boilerplate</i> clauses would have to be used instead, that just transform a short query into a long query with discarded arguments. Remember that Daki does not require all arguments in the tail dependencies to unify, contrary to Datalog.</p>

        <pre>
    > food('fruit', 'apple', 120).
    > food('fruit', 'banana', 90).
    >
    > # With boilerplate clauses
    > food(A, B) :- food(A, B, C).
    > food(A) :- food(A, B).
    >
    > food('fruit', 'apple')?
    Yes

    > food('fruit', Name)?
    Name = 'apple'

    Name = 'banana'

    >
    > # With anonymous arguments
    > food('fruit', 'apple', _)?
    Yes

    > food('fruit', Name, _)?
    Name = 'apple'

    Name = 'banana'

    >
    > # Impossible without anonymous arguments
    > food(_, _, _)?
    Yes
        </pre>

        <a name="retractions"></a>
        <h2>Retractions</h2>

        <p>You can remove a declaraction from the global table of clauses by declaring it again, with a final "<code>~</code>" instead of "<code>.</code>". The clause must be equivalent, that is, have all the same facts in the same argument order, except for the variables that may use different names.</p>

        <p>If you declare the same rule twice, executing "<code>listing</code>" will show the number of declarations next to the rule, in parenthesis:</p>

        <pre>
    > dinner(X) :- meal(X), time_of_day(18, 23).
    > dinner(X) :- meal(X), time_of_day(18, 23).
    > listing
    0: dinner(X) :- meal(X), time_of_day(18, 23). (2)
        </pre>

        <p>Conversely, to completely retract a rule you must retract it as many times as it is declared.</p>

        <p>If you declare a rule that includes logical OR relationships, and is expanded into several rules in memory, you do not need to retract each rule. Since the original statement itself is expanded into many rules, you can retract the whole statement which retracts all generated rules at once:</p>

        <pre>
    > star("Sun").
    > a(X, Y) :- ((c(Z))); ((b(X); c(X)), (b(Y); c(Y))).
    > listing
    0: star('Sun').
    1: a(X, Y) :- c(Z).
    2: a(X, Y) :- b(X), b(Y).
    3: a(X, Y) :- b(X), c(Y).
    4: a(X, Y) :- c(X), b(Y).
    5: a(X, Y) :- c(X), c(Y).

    >
    > a(X, Y) :- b(X), b(Y).
    > a(X, Y) :- c(X), c(Y)~
    > listing
    0: star('Sun').
    1: a(X, Y) :- c(Z).
    2: a(X, Y) :- b(X), b(Y). (2)
    3: a(X, Y) :- b(X), c(Y).
    4: a(X, Y) :- c(X), b(Y).

    >
    > a(X, Y) :- ((c(Z))); ((b(X); c(X)), (b(Y); c(Y)))~
    > listing
    0: star('Sun').
    1: a(X, Y) :- b(X), b(Y).
        </pre>

        <p>To reduce the amount of typying required, you can also retract in-memory rules by their index (the left-most number that appears when executing "<code>listing</code>". This is done using the built-in command "<code>retract &lt;Index&gt;</code>".</p>

        <pre>
    > a(X, Y) :- ((c(Z))); ((b(X); c(X)), (b(Y); c(Y))).
    > listing
    0: a(X, Y) :- c(Z).
    1: a(X, Y) :- b(X), b(Y).
    2: a(X, Y) :- b(X), c(Y).
    3: a(X, Y) :- c(X), b(Y).
    4: a(X, Y) :- c(X), c(Y).

    >
    > retract 2
    > retract 2
    > listing
    0: a(X, Y) :- c(Z).
    1: a(X, Y) :- b(X), b(Y).
    2: a(X, Y) :- c(X), c(Y).
        </pre>

        <a name="commands"></a>
        <h2>Environment commands</h2>

        <p>Aside from the language itself, some commands are required to perform operations related to the interpreter and global table themselves. These are:</p>

        <dl>
          <dt>quit</dt>
          <dd>Stop execution and exit the interpreter if in <i>interactive mode</i>; only stop processing the current file if in <i>consult mode</i></dd>

          <dt>select_table &lt;Name&gt;</dt>
          <dd>Changes the global table of clauses currently in use; by default, table "<code>0</code>" is active; passing no argument prints the current table number</dd>

          <dt>listing</dt>
          <dd>Prints all clauses kept in the current global table</dd>

          <dt>retract &lt;Index&gt;</dt>
          <dd>Retracts a clause from the current global table specified by index</dd>

          <dt>consult &lt;File path&gt;</dt>
          <dd>Read and interpret a Daki language file; receives file path as an argument</dd>

          <dt>add_memo &lt;Name&gt;</dt>
          <dd>Add a clause name to the list of clauses to memoize (ex: "<code>func/3</code>")</dd>

          <dt>rem_memo &lt;Name&gt;</dt>
          <dd>Remove a clause name to the list of clauses to memoize; clears the memory pertaining to that clause</dd>

          <dt>list_memo</dt>
          <dd>List all clause names of the memoization list</dd>

          <dt>clear_memo</dt>
          <dd>Clear all memory spent on clause memoization (does not clear the list of clauses to memoize)</dd>
        </dl>

        <p>These commands are executed without any trailing "<code>.</code>", "<code>?</code>" or "<code>!</code>", and are case-insensitive. The <code>memo</code> commands are made clear in the <a class="no-print" href="#memoization">memoization</a> section.</p>

        <p>The language features up to here are the minimum required for a pure, logic-based, query-only language. For many real problems, however, this is not enough.</p>

        <a name="operator-clauses"></a>
        <h2>Operator clauses</h2>

        <p>The Daki language also has built-in clauses, that unify with user-specified clauses and perform some form of calculation. To see why these are important, let's look at a practical example. In a language like Prolog, for instance, calculating a number in the Fibonacci sequence may look like:</p>

        <pre>
    fib(1, 1).
    fib(2, 1).
    fib(N, X) :- f1 = fib(N - 1, X1), f2 = fib(N - 2, X2), X is X1 + X2.
        </pre>

        <p>In Prolog we find arithmetic and conditional logic mixed with the clause itself. In the Daki language, however, we prefer to keep the clause format consistent even for these operations. We use instead what we call operator clauses.</p>

        <p>Operator clauses are always unifiable only when the input variables are present, if any, and for performance they are always unified before user-defined clauses where possible. The result of the operation is output in the last argument.</p>

        <p>Some operator clauses have variants with the same name but higher arity. This is represented by "<code>...</code>", bellow and it means that it accepts an infinite number of input arguments.</p>

        <a name="arithmetic-operator-clauses"></a>
        <h3>Arithmetic operator clauses</h3>

        <p>The inputs must be numeric to unify.</p>

        <dl>
          <dt>add(Numeric1, Numeric2, ...., Output).</dt>
          <dd>Unifies with the result of the addition of the inputs</dd>

          <dt>sub(Numeric1, Numeric2, Output).</dt>
          <dd>Unifies with the result of the subtraction of Input1 with Input2</dd>

          <dt>mul(Numeric1, Numeric2, ..., Output).</dt>
          <dd>Unifies with the result of the multiplication of the two inputs</dd>

          <dt>div(Numeric1, Numeric2, Output).</dt>
          <dd>Unifies with the result of the division of the two inputs; integer division is used if both inputs are integer</dd>

          <dt>mod(Numeric1, Numeric2, Output).</dt>
          <dd>Unifies with the rest of the integer division of the two inputs</dd>

          <dt>pow(Numeric1, Numeric2, Output).</dt>
          <dd>Unifies with the result ofInput1 to the power of Input2</dd>

          <dt>sqrt(Numeric, Output).</dt>
          <dd>Unifies with the result of the square root of Input</dd>

          <dt>log(Numeric1, Numeric2, Output).</dt>
          <dd>Unifies with the logarithmic base Input2 of Input1</dd>

          <dt>round(Numeric1, Numeric2, Output).</dt>
          <dd>Unifies with the rounded value of Input1 to Input2 decimal cases</dd>

          <dt>trunc(Numeric, Output).</dt>
          <dd>Unifies with the value of Input without decimal part</dd>

          <dt>floor(Numeric, Output).</dt>
          <dd>Unifies with the largest integer value that is less or equal to the input</dd>

          <dt>ceil(Numeric, Output).</dt>
          <dd>Unifies with the smallest integer value that is greater or equal to the input</dd>

          <dt>abs(Numeric, Output).</dt>
          <dd>Unifies with the absolute value of the input</dd>

          <dt>eval(Numeric1, ..., StringN, Output).</dt>
          <dd>Replaces the instances of a placeholder for each variable "<code>$N</code>" in StringN with each numeric value with the same index, and resolves the resulting equation; ignores whitespace; instead of using this clause directly, see <a class="no-print" href="#inline-operations">inline operations</a></dd>
        </dl>

        <a name="bitwise-operator-clauses"></a>
        <h3>Bitwise operator clauses</h3>

        <p>The inputs must be of type Integer to unify.</p>

        <dl>
          <dt>bit_and(Integer1, Integer2, Output).</dt>
          <dd>Unifies with the bitwise AND of the two inputs</dd>

          <dt>bit_or(Integer1, Integer2, Output).</dt>
          <dd>Unifies with the bitwise OR of the two inputs</dd>

          <dt>bit_xor(Integer1, Integer2, Output).</dt>
          <dd>Unifies with the bitwise XOR of the two inputs</dd>

          <dt>bit_neg(Integer, Output).</dt>
          <dd>Unifies with the bitwise inversion of the bits of the input</dd>

          <dt>bit_shift_left(Integer1, Integer2, Output).</dt>
          <dd>Unifies with the left shifted value of Integer1 by Integer2</dd>

          <dt>bit_shift_right(Integer1, Integer2, Output).</dt>
          <dd>Unifies with the right shifted value of Integer1 by Integer2</dd>
        </dl>

        <a name="comparison-operator-clauses"></a>
        <h3>Comparison operator clauses</h3>

        <p>The inputs must be both numeric or both strings to unify.</p>

        <dl>
          <dt>eql(Input1, Input2, Output).</dt>
          <dd>Unifies if the values are equal; with the string literal <code>'Yes'</code></dd>

          <dt>neq(Input1, Input2, Output).</dt>
          <dd>Unifies if the values are not equal; with the string literal <code>'Yes'</code></dd>

          <dt>max(Input1, Input2, ..., Output).</dt>
          <dd>Unifies with the maximum value between the inputs; if the inputs are strings, string comparison is used instead of numeric</dd>

          <dt>min(Input1, Input2, ..., Output).</dt>
          <dd>Unifies with the minimum value between the inputs; if the inputs are strings, string comparison is used instead of numeric</dd>

          <dt>gt(Input1, Input2, Output).</dt>
          <dd>Unifies if Input1 is greater than Input2; if any of the inputs is a string, string comparison is used instead of numeric; unifies with the string literal <code>'Yes'</code></dd>

          <dt>lt(Input1, Input2, Output).</dt>
          <dd>Unifies if Input1 is lower than Input2; if any of the inputs is a string, string comparison is used instead of numeric; unifies with the string literal <code>'Yes'</code></dd>

          <dt>gte(Input1, Input2, Output).</dt>
          <dd>Unifies if Input1 is greater or equal to Input2; if any of the inputs is a string, string comparison is used instead of numeric; unifies with the string literal <code>'Yes'</code></dd>

          <dt>lte(Input1, Input2, Output).</dt>
          <dd>Unifies if Input1 is lower or equal to Input2; if any of the inputs is a string, string comparison is used instead of numeric; unifies with the string literal <code>'Yes'</code></dd>
        </dl>

        <a name="type-casting_operator-clauses"></a>
        <h3>Type casting operator clauses</h3>

        <p>The inputs must be of the correct data type to unify.</p>

        <dl>
          <dt>as_string(Input, Output).</dt>
          <dd>Unifies with the text representation of the input (of any type)</dd>

          <dt>as_string(Integer1, Integer2, Output).</dt>
          <dd>Unifies with the text representation of Integer1, with the base specified by Integer2</dd>

          <dt>as_integer(Input, Output).</dt>
          <dd>Unifies with the integer value of the input (of any type); will truncate floating point values</dd>

          <dt>as_integer(String1, Integer2, Output).</dt>
          <dd>Unifies with the integer value of String1, with the base specified by Integer2</dd>

          <dt>as_float(Input, Output).</dt>
          <dd>Unifies with the floating point value of the input (of any type)</dd>
        </dl>

        <a name="string-operator-clauses"></a>
        <h3>String operator clauses</h3>

        <p>The inputs must be of the correct data type to unify.</p>

        <dl>
          <dt>len(String, Output).</dt>
          <dd>Unifies with the number of characters of a string input</dd>

          <dt>concat(String1, String2, ..., Output).</dt>
          <dd>Unifies with the concatenation of the string inputs</dd>

          <dt>slice(String1, Integer2, Integer3, Output).</dt>
          <dd>Unifies with the remainder of a string String1 starting at index Integer2 and ending at index Integer3, or the end of the string</dd>

          <dt>index(String1, String2, Integer3, Output).</dt>
          <dd>Unifies with the integer position of String2 if found in String1, or integer literal <code>-1</code>; searching starting from Integer3</dd>

          <dt>ord(String, Output).</dt>
          <dd>Unifies with the numeric Unicode value of the first character in the string input</dd>

          <dt>char(Integer, Output).</dt>
          <dd>Unifies with a string with the Unicode character found for the integer input</dd>

          <dt>split(String1, String2, Output).</dt>
          <dd>Unifies with a list of the separate string characters of String1, separated by String2; if String2 is the empty string (<code>''</code>), every character is separated</dd>
        </dl>

        <a name="list-operator-clauses"></a>
        <h3>List operator clauses</h3>

        <p>The inputs must be of the correct data type to unify.</p>

        <dl>
          <dt>head(List, Output).</dt>
          <dd>Unifies with the first element of the list; list must not be empty</dd>

          <dt>tail(List, Output).</dt>
          <dd>Unifies with the remaining elements of the lest after the first one; will unify with empty list (<code>[]</code>) for inputs with a single element, and will not unify with empty lists</dd>

          <dt>push(List1, Input2, Output).</dt>
          <dd>Unifies with a list with Input2 added at the beginning of List1</dd>

          <dt>append(List1, Input2, Output).</dt>
          <dd>Unifies with a list with Input2 added at the end of List1</dd>

          <dt>put(List1, Input2, Integer3, Output).</dt>
          <dd>Unifies with a list with Input2 added at position Integer3 of List1; position Integer3 must be valid</dd>

          <dt>len(List, Output).</dt>
          <dd>Unifies with the number of elements in the list</dd>

          <dt>concat(List1, List2, ..., Output).</dt>
          <dd>Unifies with the concatenation of the list inputs into one</dd>

          <dt>slice(List1, Integer2, Integer3, Output).</dt>
          <dd>Unifies with the remainder of list List1 starting at index Integer2 and ending at index Integer3, or the end of the list</dd>

          <dt>index(List1, Input2, Integer3, Output).</dt>
          <dd>Unifies with the integer position of Input2 if found in List1, or integer literal <code>-1</code>; the search starts from index Integer3</dd>

          <dt>unique(List, Output).</dt>
          <dd>Unifies with the the list of unique elements</dd>

          <dt>reverse(List, Output).</dt>
          <dd>Unifies with the the list with all elements in the inverse positions</dd>

          <dt>sort(List, Output).</dt>
          <dd>Sorts all the elements of the list; all must be of a similar type: numeric, strings or lists</dd>

          <dt>sum(List, Output).</dt>
          <dd>Sum all the elements of the list; all must be of a similar type: numeric, strings or lists; the sum of strings will have a similar output to <code>join/3</code>, and the sum of lists a similar output to <code>concat/3</code></dd>

          <dt>max(List, Output).</dt>
          <dd>Find the maximum value of all the elements of the list; all must be of a similar type: numeric, strings or lists</dd>

          <dt>min(List, Output).</dt>
          <dd>Find the minimum value of all the elements of the list; all must be of a similar type: numeric, strings or lists</dd>

          <dt>join(List1, String2, Output).</dt>
          <dd>Converts each element of the list to string and joins the strings with the String2 separator</dd>

          <dt>init(Integer1, Input2, Output).</dt>
          <dd>Unifies with a list of size Integer1 with each element set to Input2</dd>
        </dl>

        <a name="other-operator-clauses"></a>
        <h3>Other operator clauses</h3>

        <p>These always unify.</p>

        <dl>
          <dt>set(Input, Output).</dt>
          <dd>Just transposes the input to the ouput variable</dd>

          <dt>rand(Output).</dt>
          <dd>Unifies with a random floating point value between 0 and 1</dd>

          <dt>type(Input, Output).</dt>
          <dd>Unifies with the string literal of the name of the data type of Input: <code>'string'</code>, <code>'integer'</code> or <code>'float'</code></dd>

          <dt>print(Input, Output).</dt>
          <dd>Print Input to the console; unifies with the string literal <code>'Yes'</code></dd>

          <dt>print(Input1, Input2, Output).</dt>
          <dd>Print Inpu1 to the console; Input2 is used to enforce order of execution; unifies with the string literal <code>'Yes'</code></dd>

          <dt>time(Output).</dt>
          <dd>Unifies with the integer number of milliseconds since the UNIX epoch</dd>

          <dt>time(Input, Output).</dt>
          <dd>Unifies with the integer number of milliseconds since the UNIX epoch; the input is used to enforce order of execution</dd>
        </dl>

        <p>Operator clauses cannot be overwritten or retracted with clauses with the same name and arity. They also only unify with some data types - for instance an arithmetic clause will not unify with string arguments. Illegal argument combinations, like trying to divide by 0, also do not unify.</p>

        <p>Let's now go back to how to implement a program that returns the value of the Fibonacci sequence at position N. At first glance, the solution in Daki would be:</p>

        <pre>
    > fib(1, 1).
    > fib(2, 1).
    > fib(N, Res) :- gt(N, 2, Y), sub(N, 1, N1), sub(N, 2, N2), fib(N1, F1), fib(N2, F2), \
                     add(F1, F2, Res).
        </pre>

        <p>Since this solution is recursive: a dependency on <code>fib</code> will try all solutions by expanding all clauses named <code>fib</code>, including itself; does this result in an infinite cycle? Not quite. A Daki interpreter is smart enough to stop the whole tail calculation when one of it's parts is proven impossible to unify, and most cases we don't have to think hard about this: operator clauses are guaranteed to have higher priority to being processed, and thus the expansion of the clause tail can be aborted sooner.</p>

        <a name="clause-conditions"></a>
        <h2>Clause conditions</h2>

        <p>The Daki interpreter, however, is not all-knowing. A more complex example may require many clause expansions to reach a falsifiable part. The best solution would be to avoid expanding clauses dependencies as early as possible.</p>

        <p>This is best achieved by using what we call clause conditions. Clause conditions are boolean tests on variables of the head of candidate clauses to be evaluated. The condition is tested at the clause selection phase, which is more efficient. With clause conditions our Fibonacci program becomes:</p>

        <pre>
    > fib(1, 1).
    > fib(2, 1).
    > fib(N > 2, Res) :- sub(N, 1, N1), sub(N, 2, N2), fib(N1, X1), fib(N2, X2), \
                         add(X1, X2, Res).
        </pre>

        <p>The clause condition <code>fib(N > 2, Res)</code> restricts matching N to values greater than the numeric value 2. The full list of operators is as follows.</p>

        <a name="condition-operators"></a>
        <h3>Condition Operators</h3>

        <dl>
          <dt><</dt>
          <dd>Tests if the variable is lower than the literal; not available for <code>list</code> types</dd>

          <dt><=</dt>
          <dd>Tests if the variable is lower or equal to the literal; not available for <code>list</code> types</dd>

          <dt>></dt>
          <dd>Tests if the variable is greater than the literal; not available for <code>list</code> types</dd>

          <dt>>=</dt>
          <dd>Tests if the variable is greater or equal to the literal; not available for <code>list</code> types</dd>

          <dt><></dt>
          <dd>Tests if the variable is not equal to the literal</dd>

          <dt>:</dt>
          <dd>Tests if the data type of the variable is the literal value (from <code>'integer'</code>, <code>'float'</code>, <code>'string'</code> or <code>'list'</code>)</dd>
        </dl>

        <p>Clause conditions are exclusively between a variable and a literal value, and different data types never unify, except if they are both numeric. This contrasts with the usual clause matching rules that do not unify integer with floating point literals. The comparison operators use alphabetical order for strings.</p>

        <p>Also note that you can mix multiple conditions. A variable must match all conditions for the clause to be expanded:</p>

        <pre>
    > positive_except_five1(0 < N, N <> 5.0).
    > positive_except_five(N) :- positive_except_five1(N, N).
    >
    > positive_except_five(3)?
    Yes

    > positive_except_five(4.50)?
    Yes

    > positive_except_five(5)?
    No

    > positive_except_five(-3)?
    No

    > positive_except_five('1')?
    No

    > is_string(X: 'string').
    > is_string(1)?
    No

    > is_string(1.0)?
    No

    > is_string("1")?
    Yes

    > is_float(X: 'float').
    > is_float(1)?
    No

    > is_float(1.0)?
    Yes

    > is_float("1")?
    No

    > is_integer(X: 'integer').
    > is_integer(1)?
    Yes

    > is_integer(1.0)?
    No

    > is_integer("1")?
    No

    > is_numeric(X) :- is_float(X); is_integer(X).
    > is_numeric(1)?
    Yes

    > is_numeric(1.0)?
    Yes

    > is_numeric("1")?
    No
        </pre>

        <p>As a last example, we can also benchmark how fast our two Fibonacci functions are, by making use of the <code>time/2</code> and <code>time/3</code> operator clauses:</p>

        <pre>
    > # Using only operator clauses
    > fib1(1, 1).
    > fib1(2, 1).
    > fib1(N, Res) :- gt(N, 2, gt), sub(N, 1, N1), sub(N, 2, N2), fib1(N1, X1), \
                      fib1(N2, X2), add(X1, X2, Res).
    > time_fib1(N, Val, Elapsed) :- time(StartTime), fib1(N, Val), time(Val, EndTime), \
                                    sub(EndTime, StartTime, Elapsed).
    >
    > time_fib1(10, Val, Elapsed)?
    Val = 144
    Elapsed = 161

    > # Using a clause condition
    > fib2(1, 1).
    > fib2(2, 1).
    > fib2(N > 2, Res) :- sub(N, 1, N1), sub(N, 2, N2), fib2(N1, X1), fib2(N2, X2), \
                          add(X1, X2, Res).
    > time_fib2(N, Val, Elapsed) :- time(StartTime), fib2(N, Val), time(Val, EndTime), \
                                    sub(EndTime, StartTime, Elapsed).
    >
    > time_fib2(10, Val, Elapsed)?
    Val = 144
    Elapsed = 99
        </pre>

        <p>As you can see, using only operator clauses where a clause condition could've been used can result in a large performance penalty. Operator clauses are obviously still useful for intermediate calculations, but should be avoided for logic control.</p>

        <a name="inline-operations"></a>
        <h2>Inline Operations</h2>

        Even though operator clauses are very powerful, it can still be somewhat cumbersome to write mathematical formulas using them. For this reasion, some of the more common numeric operations can still be used <i>inline</i>, as such:

        <pre>
    > is_power(N, N2) :- eql(N * N, N2, Res).
    > is_power(3, 9)?
    Yes

    > print_more(N, L) :- print(N + (L * 2), Out1), \
                          print(N * 2, Out2), \
                          print(N * N, Out3), \
                          print((N + 1) * N + 1, Out4).
    > print_more(5, 2)?
    9
    10
    25
    31
    Yes
        </pre>

        <p>Inline operations are limited to the following numeric operations and the use of parenthesis. Invalid operations like dividing by zero do not unify.</p>

        <a name="inline-operators"></a>
        <h3>Inline Operators</h3>

        <dl>
          <dt>+</dt>
          <dd>Numeric addition</dd>

          <dt>-</dt>
          <dd>Numeric subtraction</dd>

          <dt>*</dt>
          <dd>Numeric multiplication</dd>

          <dt>/</dt>
          <dd>Numeric division; integer division if both operands are integer</dd>

          <dt>%</dt>
          <dd>Remainder of the numeric division</dd>

          <dt>&</dt>
          <dd>Bitwise AND</dd>

          <dt>|</dt>
          <dd>Bitwise OR</dd>

          <dt>^</dt>
          <dd>Bitwise XOR</dd>

          <dt>~</dt>
          <dd>Bitwise complement</dd>
        </dl>

        <p>Notice the bitwise complement operator is the only one with a single operand. It is used as, for example, "<code>~123</code>", so you will need to surround it with parenthesis if in the middle of a longer expression.</p>

        <p>In practice, inline operations are expanded into using the <code>eval</code> operator clause with an intermediate variable for the output. You can see this seamless expansion by using the command <code>listing</code>.</p>

        <pre>
    > sum_of_powers(X, Y, Res) :- set((X * X) + (Y * Y), Res).
    > sum_of_powers(3, 2, Sum)?
    Sum = 13

    > listing
    0: sum_of_powers(X, Y, Res) :- eval(X, Y, '($0*$0)+($1*$1)', $1), set($1, Res).
        </pre>

        <p>Inline operations, the <code>eval</code> operator clause and in fact the entire parsing algorithm uses <i>deterministic finite-state machines</i> for the evaluation. Because of this the operators do not have an intrinsic operator priority, they are evaluated sequentially. You must use parenthesis to enforce an evaluation order.</p>

        <a name="memoization"></a>
        <h2>Memoization</h2>

        <p>In the last example where we calculated the value of position N of the Fibonacci sequence, we were recalculating many intermediate values. In some contexts, this is required, because a clause can be expanded in many ways; other types this can be avoided, and we can apply memoization to the known unifiable forms of the clause.</p>

        <p>In the Daki language this is done by telling the interpreter what functions can be memoized:</p>

        <pre>
    > # Having fib1, fib2, time_fib1 and time_fib2 defined before
    >
    > add_memo fib1/2
    OK

    > add_memo fib2/2
    OK

    >
    > time_fib1(12, Val, Elapsed)?
    Val = 144
    Elapsed = 11

    > time_fib2(12, Val, Elapsed)?
    Val = 144
    Elapsed = 8

    >
    > # Values have already been completely memoized:
    >
    > time_fib1(12, Val, Elapsed)?
    Val = 144
    Elapsed = 0

    > time_fib2(12, Val, Elapsed)?
    Val = 144
    Elapsed = 0
        </pre>

        <p>In this example, we have instructed the interpreter to remember the argument configurations for which our functions unify, and, where possible, to reuse those configurations instead of starting new searches. We must be very careful to be consistent in how we expand our requirements on a memoized clause. If we later tried to find out all positions in the Fibonacci sequence for which the value is 1, it would fail to give all the solutions, because it has already cached one configuration that unifies:</p>

        <pre>
    > fib2(X, 1)?
    X = 1
        </pre>

        <p>Memoization is always relative to a global clauses table. Changing to another table will use another memoization tree. Adding or retracting individual clauses does not affect what clauses are memoized, nor is the process memory cleared, use the built-in commands <code>rem_memo</code> and <code>clear_memo</code> for that.</p>

        <p>As a last example, let's create a small program that prints the first twenty elements of the Fibonnaci sequence, using memoization, lists and inline operations:</p>

        <pre>
    > add_memo fib/2
    OK

    >
    > fib(1, 1).
    > fib(2, 1).
    > fib(N > 2, Res) :- fib(N - 1, X1), fib(N - 2, X2), add(X1, X2, Res).
    >
    > fib_seq(0, []).
    > fib_seq(N > 0, Out) :- fib(N, Val), init(1, Val, Out2), fib_seq(N - 1, Out1), \
                             concat(Out1, Out2, Out).
    >
    > time_fib2(N, Out, Elapsed) :- time(StartTime), \
                                    fib_seq(N, Out), \
                                    time(Out, EndTime), \
                                    sub(EndTime, StartTime, Elapsed).
    >
    > print_fib(N) :- time_fib2(N, Out, Elapsed), \
                      join(Out, ", ", Seq), \
                      concat("Sequence: ", Seq, Line1), \
                      print(Line1, ok), \
                      as_string(Elapsed, ElapsedStr), \
                      concat("Elapsed (ms): ", ElapsedStr, Line2), \
                      print(Line2, ok).
    >
    > print_fib(20)?
    Sequence: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 41
    81, 6765
    Elapsed (ms): 95
    Yes
        </pre>

        <hr/>
        <a name="copyright"></a>

        <p>Copyright (c) 2021 Gonçalo Mendes Ferreira</p>

        <p>Permission to use, copy, modify, and/or distribute this document for any purpose
        with or without fee is hereby granted, provided that the above copyright notice
        and this permission notice appear in all copies.</p>
      </main>
    </div>

    <img src="https://macro-win.goatcounter.com/count?p=/daki_spec.html" alt="" />
  </body>
</html>
